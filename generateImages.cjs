// generateImages.cjs
// ⚠️ Auto-generated helper: scans public/images and writes src/images.ts
// Run: npm run gen:images

const fs = require("fs");
const path = require("path");
const sharp = require("sharp");

const PUBLIC_IMAGES = path.join(__dirname, "public", "images");
const OUTPUT = path.join(__dirname, "src", "images.ts");

// Allowed image extensions
const exts = new Set([".png", ".jpg", ".jpeg", ".gif", ".webp", ".avif", ".svg"]);

// Optimization settings
const MAX_WIDTH = 2000; // px
const OPT_SUFFIX = "_web"; // Suffix for optimized images

if (!fs.existsSync(PUBLIC_IMAGES)) {
  console.error("❌ Folder not found:", PUBLIC_IMAGES);
  process.exit(1);
}

fs.mkdirSync(path.dirname(OUTPUT), { recursive: true });

// Store both nested + flat arrays
const flatArrays = {};
function pascalCaseVar(parts) {
  return parts
    .map((p) =>
      p
        .replace(/[^a-zA-Z0-9]+/g, " ")
        .trim()
        .replace(/\s+(\w)/g, (_, c) => c.toUpperCase())
        .replace(/^\w/, (c) => c.toUpperCase())
    )
    .join("");
}

async function optimizeImage(fullPath) {
  try {
    const image = sharp(fullPath);
    const metadata = await image.metadata();
    if (metadata.width > MAX_WIDTH) {
      const { dir, name, ext } = path.parse(fullPath);
      const outName = `${name}${OPT_SUFFIX}${ext}`;
      const outPath = path.join(dir, outName);
      // Only create if not exists
      if (!fs.existsSync(outPath)) {
        await image.resize({ width: MAX_WIDTH }).toFile(outPath);
        console.log(`🗜️ Optimized: ${outPath}`);
      }
      return outPath;
    }
  } catch (err) {
    console.warn("⚠️ Sharp error:", fullPath, err.message);
  }
  return fullPath;
}

async function walk(dir, parts = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const node = {};
  const collected = [];

  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const full = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      node[entry.name] = await walk(full, [...parts, entry.name]);
    } else {
      const ext = path.extname(entry.name).toLowerCase();
      if (!exts.has(ext)) continue;

      const key = path.parse(entry.name).name;
      let rel;
      let optimizedPath = full;

      // Only optimize raster images (skip SVG)
      if (ext !== ".svg") {
        optimizedPath = await optimizeImage(full);
      }

      rel =
        "/" +
        path.join("images", path.relative(PUBLIC_IMAGES, optimizedPath)).replace(/\\/g, "/");

      node[key] = rel;
      collected.push(rel);
    }
  }

  // If folder had images, create a flat array variable
  if (collected.length > 0) {
    const varName = pascalCaseVar(parts);
    if (varName) {
      flatArrays[varName] = collected;
    }
  }

  return node;
}

(async () => {
  const data = await walk(PUBLIC_IMAGES);

  const header = `// Auto-generated by generateImages.cjs on ${new Date().toISOString()}
// Do not edit manually. Re-run the script after changing files under public/images.
`;

  let ts = `${header}export const images = ${JSON.stringify(data, null, 2)} as const;\n`;
  ts += `export type ImagesMap = typeof images;\n\n`;

  // Export flat arrays
  for (const [name, arr] of Object.entries(flatArrays)) {
    ts += `export const ${name} = ${JSON.stringify(arr, null, 2)} as const;\n`;
  }

  fs.writeFileSync(OUTPUT, ts, "utf-8");
  console.log("✅ Wrote", path.relative(process.cwd(), OUTPUT));
})();

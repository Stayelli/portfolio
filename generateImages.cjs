// generateImages.cjs
// ⚠️ Auto-generated helper: scans public/images and writes src/images.ts
// Run: npm run gen:images

const fs = require("fs");
const path = require("path");

const PUBLIC_IMAGES = path.join(__dirname, "public", "images");
const OUTPUT = path.join(__dirname, "src", "images.ts");

// Allowed image extensions
const exts = new Set([".png", ".jpg", ".jpeg", ".gif", ".webp", ".avif", ".svg"]);

if (!fs.existsSync(PUBLIC_IMAGES)) {
  console.error("❌ Folder not found:", PUBLIC_IMAGES);
  process.exit(1);
}

fs.mkdirSync(path.dirname(OUTPUT), { recursive: true });

// Store both nested + flat arrays
const flatArrays = {};
function pascalCaseVar(parts) {
  return parts
    .map((p) =>
      p
        .replace(/[^a-zA-Z0-9]+/g, " ")
        .trim()
        .replace(/\s+(\w)/g, (_, c) => c.toUpperCase())
        .replace(/^\w/, (c) => c.toUpperCase())
    )
    .join("");
}

function walk(dir, parts = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const node = {};
  const collected = [];

  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const full = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      node[entry.name] = walk(full, [...parts, entry.name]);
    } else {
      const ext = path.extname(entry.name).toLowerCase();
      if (!exts.has(ext)) continue;

      const key = path.parse(entry.name).name;
      const rel =
        "/" +
        path.join("images", path.relative(PUBLIC_IMAGES, full)).replace(/\\/g, "/");

      node[key] = rel;
      collected.push(rel);
    }
  }

  // If folder had images, create a flat array variable
  if (collected.length > 0) {
    const varName = pascalCaseVar(parts);
    if (varName) {
      flatArrays[varName] = collected;
    }
  }

  return node;
}

const data = walk(PUBLIC_IMAGES);

const header = `// Auto-generated by generateImages.cjs on ${new Date().toISOString()}
// Do not edit manually. Re-run the script after changing files under public/images.
`;

let ts = `${header}export const images = ${JSON.stringify(data, null, 2)} as const;\n`;
ts += `export type ImagesMap = typeof images;\n\n`;

// Export flat arrays
for (const [name, arr] of Object.entries(flatArrays)) {
  ts += `export const ${name} = ${JSON.stringify(arr, null, 2)} as const;\n`;
}

fs.writeFileSync(OUTPUT, ts, "utf-8");
console.log("✅ Wrote", path.relative(process.cwd(), OUTPUT));
